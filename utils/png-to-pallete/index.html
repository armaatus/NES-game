<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NES Tileset Color Converter - CHR Ready</title>
    <link rel="stylesheet" href="main.css" />
  </head>
  <body>
    <div class="container">
      <h1>NES Tileset Color Converter - CHR Ready</h1>
      <p class="explain">
        Found myself struggling with creating and even finding tiles for testing
        my NES game, so this script converts all colors to 4 colors max and the
        colors of the NES that are closest. It also creates and image with a
        single pallete that can be imported into PNG to CHR converters
      </p>

      <div class="upload-section">
        <h2>Upload PNG Tileset</h2>
        <p class="info-text">
          Import a PNG with 8x8 tiles to convert to NES color restrictions.<br />
          Each tile will use max 4 colors from the NES palette.
        </p>
        <input type="file" id="fileInput" accept="image/png" />
        <button
          class="upload-btn"
          onclick="document.getElementById('fileInput').click()"
        >
          Choose PNG File
        </button>
      </div>

      <div class="results-section" id="results">
        <h2 class="section-title">Original Image</h2>
        <div class="canvas-container">
          <canvas id="originalCanvas"></canvas>
        </div>

        <h2 class="section-title">
          Converted to NES Colors (Individual Palettes)
        </h2>
        <div class="canvas-container">
          <canvas id="convertedCanvas"></canvas>
          <button
            class="download-btn"
            onclick="downloadCanvas('convertedCanvas', 'nes_converted.png')"
          >
            Download Converted Image
          </button>
        </div>

        <h2 class="section-title">Using Shared Palette</h2>
        <div class="canvas-container">
          <canvas id="sharedPaletteCanvas"></canvas>
          <button
            class="download-btn"
            onclick="downloadCanvas('sharedPaletteCanvas', 'nes_shared_palette.png')"
          >
            Download Shared Palette Image
          </button>
        </div>

        <div class="stats-section">
          <h3>Color Usage Statistics</h3>
          <div id="colorStats"></div>
          <h3>Most Used Colors</h3>
          <div id="colorHistogram" class="color-histogram"></div>
        </div>

        <h2 class="section-title">Tile Palettes</h2>
        <div id="palettesContainer" class="palette-grid"></div>
      </div>
    </div>

    <script>
      // NES color palette (2C02 PPU) - complete 64 color palette
      const NES_PALETTE = [
        // 0x00-0x0F
        [124, 124, 124],
        [0, 0, 252],
        [0, 0, 188],
        [68, 40, 188],
        [148, 0, 132],
        [168, 0, 32],
        [168, 16, 0],
        [136, 20, 0],
        [80, 48, 0],
        [0, 120, 0],
        [0, 104, 0],
        [0, 88, 0],
        [0, 64, 88],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        // 0x10-0x1F
        [188, 188, 188],
        [0, 120, 248],
        [0, 88, 248],
        [104, 68, 252],
        [216, 0, 204],
        [228, 0, 88],
        [248, 56, 0],
        [228, 92, 16],
        [172, 124, 0],
        [0, 184, 0],
        [0, 168, 0],
        [0, 168, 68],
        [0, 136, 136],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        // 0x20-0x2F
        [248, 248, 248],
        [60, 188, 252],
        [104, 136, 252],
        [152, 120, 248],
        [248, 120, 248],
        [248, 88, 152],
        [248, 120, 88],
        [252, 160, 68],
        [248, 184, 0],
        [184, 248, 24],
        [88, 216, 84],
        [88, 248, 152],
        [0, 232, 216],
        [120, 120, 120],
        [0, 0, 0],
        [0, 0, 0],
        // 0x30-0x3F
        [252, 252, 252],
        [164, 228, 252],
        [184, 184, 248],
        [216, 184, 248],
        [248, 184, 248],
        [248, 164, 192],
        [240, 208, 176],
        [252, 224, 168],
        [248, 216, 120],
        [216, 248, 120],
        [184, 248, 184],
        [184, 248, 216],
        [0, 252, 252],
        [248, 216, 248],
        [0, 0, 0],
        [0, 0, 0],
      ];

      // Color names for better debugging
      const COLOR_NAMES = {
        "0,0,0": "Black",
        "124,124,124": "Dark Gray",
        "188,188,188": "Light Gray",
        "248,248,248": "White",
        "252,252,252": "Bright White",
        "0,0,252": "Blue",
        "0,0,188": "Dark Blue",
        "0,88,248": "Medium Blue",
        "0,120,248": "Light Blue",
        "60,188,252": "Sky Blue",
        "104,136,252": "Pale Blue",
        "0,232,216": "Cyan",
        "0,252,252": "Bright Cyan",
        "0,136,136": "Teal",
        "0,168,68": "Sea Green",
        "0,184,0": "Green",
        "0,168,0": "Dark Green",
        "88,216,84": "Light Green",
        "184,248,24": "Yellow Green",
        "248,184,0": "Orange",
        "252,160,68": "Light Orange",
        "248,56,0": "Red Orange",
        "228,0,88": "Red",
        "168,0,32": "Dark Red",
        "248,88,152": "Pink",
        "248,120,248": "Magenta",
        "216,0,204": "Purple",
      };

      let tilePalettes = [];
      let globalColorUsage = {};
      let sharedPalette = null;

      function getNESColorIndex(color) {
        for (let i = 0; i < NES_PALETTE.length; i++) {
          if (
            NES_PALETTE[i][0] === color[0] &&
            NES_PALETTE[i][1] === color[1] &&
            NES_PALETTE[i][2] === color[2]
          ) {
            let output = i.toString(16).toUpperCase().padStart(2, "0");
            return output !== "0D" ? output : "0F";
            return i.toString(16).toUpperCase().padStart(2, "0");
          }
        }
        return "??";
      }

      function getColorName(color) {
        const key = color.join(",");
        return COLOR_NAMES[key] || `RGB(${key})`;
      }

      document
        .getElementById("fileInput")
        .addEventListener("change", handleFileUpload);

      function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (event) {
          const img = new Image();
          img.onload = function () {
            processImage(img);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }

      function processImage(img) {
        const originalCanvas = document.getElementById("originalCanvas");
        const convertedCanvas = document.getElementById("convertedCanvas");
        const sharedPaletteCanvas = document.getElementById(
          "sharedPaletteCanvas",
        );

        // Set canvas sizes
        originalCanvas.width =
          convertedCanvas.width =
          sharedPaletteCanvas.width =
            img.width;
        originalCanvas.height =
          convertedCanvas.height =
          sharedPaletteCanvas.height =
            img.height;

        // Draw original
        const originalCtx = originalCanvas.getContext("2d");
        originalCtx.drawImage(img, 0, 0);

        // Process tiles
        const imageData = originalCtx.getImageData(0, 0, img.width, img.height);
        const convertedData = new ImageData(img.width, img.height);
        const sharedPaletteData = new ImageData(img.width, img.height);

        tilePalettes = [];
        globalColorUsage = {};

        // Process each 8x8 tile
        const tilesX = Math.floor(img.width / 8);
        const tilesY = Math.floor(img.height / 8);

        // First pass: analyze all tiles and build color usage stats
        for (let ty = 0; ty < tilesY; ty++) {
          for (let tx = 0; tx < tilesX; tx++) {
            const tile = extractTile(imageData, tx * 8, ty * 8);
            const nesColoredTile = tile.map((color) =>
              findClosestNESColor(color),
            );

            // Count global color usage
            nesColoredTile.forEach((color) => {
              const key = color.join(",");
              globalColorUsage[key] = (globalColorUsage[key] || 0) + 1;
            });
          }
        }

        // Generate shared palette from most used colors
        sharedPalette = generateSharedPalette(globalColorUsage);

        // Second pass: generate individual palettes and apply conversions
        for (let ty = 0; ty < tilesY; ty++) {
          for (let tx = 0; tx < tilesX; tx++) {
            const tile = extractTile(imageData, tx * 8, ty * 8);
            const palette = generateTilePalette(tile);
            tilePalettes.push({
              x: tx,
              y: ty,
              palette: palette,
            });

            // Apply individual palette to tile
            applyPaletteToTile(
              imageData,
              convertedData,
              tx * 8,
              ty * 8,
              palette,
            );

            // Apply shared palette to tile
            applyPaletteToTile(
              imageData,
              sharedPaletteData,
              tx * 8,
              ty * 8,
              sharedPalette,
            );
          }
        }

        // Draw results
        const convertedCtx = convertedCanvas.getContext("2d");
        convertedCtx.putImageData(convertedData, 0, 0);

        const sharedPaletteCtx = sharedPaletteCanvas.getContext("2d");
        sharedPaletteCtx.putImageData(sharedPaletteData, 0, 0);

        // Display palettes and stats
        displayPalettes();
        displayColorStats();

        // Show results
        document.getElementById("results").style.display = "block";
      }

      function extractTile(imageData, x, y) {
        const tile = [];
        for (let py = 0; py < 8; py++) {
          for (let px = 0; px < 8; px++) {
            const idx = ((y + py) * imageData.width + (x + px)) * 4;
            tile.push([
              imageData.data[idx],
              imageData.data[idx + 1],
              imageData.data[idx + 2],
            ]);
          }
        }
        return tile;
      }

      function generateSharedPalette(colorUsage) {
        // Sort colors by usage and take top 4
        const sorted = Object.entries(colorUsage)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 4)
          .map(([color]) => color.split(",").map(Number));

        // Ensure we have 4 colors
        while (sorted.length < 4) {
          sorted.push([0, 0, 0]);
        }

        return sorted;
      }

      function generateTilePalette(tile) {
        // Convert all colors to NES colors first
        const nesColors = tile.map((color) => findClosestNESColor(color));

        // Count color usage in this tile
        const colorCount = {};
        nesColors.forEach((color) => {
          const key = color.join(",");
          colorCount[key] = (colorCount[key] || 0) + 1;
        });

        // Sort by usage and take top 4
        const sorted = Object.entries(colorCount)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 4)
          .map(([color]) => color.split(",").map(Number));

        // Ensure we have 4 colors (pad with safe black $0F if needed)
        while (sorted.length < 4) {
          sorted.push([0, 0, 0]); // $0F - safe black
        }

        return sorted;
      }

      function findClosestNESColor(color) {
        let minDist = Infinity;
        let closest = NES_PALETTE[0];

        // Special handling for very dark colors
        const brightness = (color[0] + color[1] + color[2]) / 3;
        if (brightness < 20) {
          // Use safe black $0F instead of problematic $0D
          return [0, 0, 0]; // This is index 0x0F in our palette
        }

        // Convert RGB to HSL for better color matching
        const hsl1 = rgbToHsl(color[0], color[1], color[2]);

        for (let i = 0; i < NES_PALETTE.length; i++) {
          const nesColor = NES_PALETTE[i];

          // Skip color $0D (the "blacker than black" that causes TV problems)
          // Also skip duplicate blacks (0x0E, 0x1D-0x1F, 0x2E-0x2F, 0x3E-0x3F)
          if (
            i === 0x0d ||
            i === 0x0e ||
            (i >= 0x1d && i <= 0x1f) ||
            (i >= 0x2e && i <= 0x2f) ||
            (i >= 0x3e && i <= 0x3f)
          ) {
            continue;
          }

          const hsl2 = rgbToHsl(nesColor[0], nesColor[1], nesColor[2]);

          // For grayscale colors, use simple RGB distance
          if (hsl1[1] < 10 || hsl2[1] < 10) {
            const dist = Math.sqrt(
              Math.pow(color[0] - nesColor[0], 2) +
                Math.pow(color[1] - nesColor[1], 2) +
                Math.pow(color[2] - nesColor[2], 2),
            );
            if (dist < minDist) {
              minDist = dist;
              closest = nesColor;
            }
            continue;
          }

          // For colored pixels, use weighted HSL distance
          const hueDiff = Math.min(
            Math.abs(hsl1[0] - hsl2[0]),
            360 - Math.abs(hsl1[0] - hsl2[0]),
          );

          // Normalize differences to 0-1 range
          const hueWeight = hueDiff / 180; // Max hue diff is 180
          const satWeight = Math.abs(hsl1[1] - hsl2[1]) / 100;
          const lumWeight = Math.abs(hsl1[2] - hsl2[2]) / 100;

          // Different weights for different color properties
          // Hue is most important for color identity
          const dist = hueWeight * 3.0 + satWeight * 1.5 + lumWeight * 1.0;

          if (dist < minDist) {
            minDist = dist;
            closest = nesColor;
          }
        }

        return closest;
      }

      function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h,
          s,
          l = (max + min) / 2;

        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

          switch (max) {
            case r:
              h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
              break;
            case g:
              h = ((b - r) / d + 2) / 6;
              break;
            case b:
              h = ((r - g) / d + 4) / 6;
              break;
          }
        }

        return [h * 360, s * 100, l * 100];
      }

      function findClosestPaletteColor(color, palette) {
        let minDist = Infinity;
        let closest = palette[0];

        for (const pColor of palette) {
          const dist = Math.sqrt(
            Math.pow(color[0] - pColor[0], 2) +
              Math.pow(color[1] - pColor[1], 2) +
              Math.pow(color[2] - pColor[2], 2),
          );

          if (dist < minDist) {
            minDist = dist;
            closest = pColor;
          }
        }

        return closest;
      }

      function applyPaletteToTile(sourceData, targetData, x, y, palette) {
        for (let py = 0; py < 8; py++) {
          for (let px = 0; px < 8; px++) {
            const idx = ((y + py) * sourceData.width + (x + px)) * 4;
            const color = [
              sourceData.data[idx],
              sourceData.data[idx + 1],
              sourceData.data[idx + 2],
            ];

            // First convert to NES color
            const nesColor = findClosestNESColor(color);
            // Then find closest color in the palette
            const paletteColor = findClosestPaletteColor(nesColor, palette);

            targetData.data[idx] = paletteColor[0];
            targetData.data[idx + 1] = paletteColor[1];
            targetData.data[idx + 2] = paletteColor[2];
            targetData.data[idx + 3] = 255;
          }
        }
      }

      function displayPalettes() {
        const container = document.getElementById("palettesContainer");
        container.innerHTML = "";

        // Show shared palette first
        const sharedDiv = document.createElement("div");
        sharedDiv.className = "palette-item";
        sharedDiv.style.background = "#e3f2fd";
        sharedDiv.innerHTML = `
          <div><strong>Shared Palette (Most Used)</strong></div>
          <div class="palette-colors">
            ${sharedPalette
              .map((color) => {
                const colorIndex = getNESColorIndex(color);
                const name = getColorName(color);
                return `<div class="color-box" style="background: rgb(${color.join(",")})" title="${name}">${colorIndex}</div>`;
              })
              .join("")}
          </div>
        `;
        container.appendChild(sharedDiv);

        // Show individual tile palettes
        tilePalettes.forEach((tile, index) => {
          const div = document.createElement("div");
          div.className = "palette-item";
          div.innerHTML = `
            <div>Tile ${index} (${tile.x}, ${tile.y})</div>
            <div class="palette-colors">
              ${tile.palette
                .map((color) => {
                  const colorIndex = getNESColorIndex(color);
                  const name = getColorName(color);
                  return `<div class="color-box" style="background: rgb(${color.join(",")})" title="${name}">${colorIndex}</div>`;
                })
                .join("")}
            </div>
          `;
          container.appendChild(div);
        });
      }

      function displayColorStats() {
        const statsDiv = document.getElementById("colorStats");
        const histogramDiv = document.getElementById("colorHistogram");

        // Sort colors by usage
        const sortedColors = Object.entries(globalColorUsage)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 16); // Show top 16 colors

        // Display stats
        const totalPixels = Object.values(globalColorUsage).reduce(
          (a, b) => a + b,
          0,
        );
        statsDiv.innerHTML = `
          <p>Total pixels: ${totalPixels}</p>
          <p>Unique NES colors used: ${Object.keys(globalColorUsage).length}</p>
        `;

        // Display histogram
        histogramDiv.innerHTML = sortedColors
          .map(([color, count]) => {
            const rgb = color.split(",").map(Number);
            const percentage = ((count / totalPixels) * 100).toFixed(1);
            const colorIndex = getNESColorIndex(rgb);
            const name = getColorName(rgb);
            return `
              <div class="histogram-color">
                <div class="histogram-box" style="background: rgb(${color})" title="${name}"></div>
                <div>${colorIndex}</div>
                <div>${percentage}%</div>
              </div>
            `;
          })
          .join("");
      }

      function downloadCanvas(canvasId, filename) {
        const canvas = document.getElementById(canvasId);
        const link = document.createElement("a");
        link.download = filename;
        link.href = canvas.toDataURL();
        link.click();
      }
    </script>
  </body>
</html>
